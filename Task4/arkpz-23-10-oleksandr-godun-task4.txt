Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




Лабораторна робота №4
з дисципліни: «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА IoT КЛІЄНТА»







Виконав
ст. гр. ПЗПІ-23-10
Годун Олександр Васильович


Перевірили викладачі:
Дашенков Д. С.




Харків 2025
     
Мета роботи
     
     Хід виконання роботи
     1. Будова програмного забезпечення ІоТ клієнта
     У межах цього проєкту IoT-клієнт працює як окремий невеликий модуль, який імітує поведінку реального пристрою ESP32. Його роль доволі проста: він «слухає» сервер, отримує від нього команди й виконує їх у вигляді циклу фокус-сесій. Це дозволяє відтворити роботу справжнього розумного таймера, але без необхідності використовувати апаратне забезпечення.
     Структура клієнта складається з трьох логічних частин.
     Перша відповідає за стан пристрою – там зберігаються лише кілька важливих змінних: чи запущений цикл, яка тривалість фокус-сесії та перерви, і чи потрібно цей цикл зупинити. Це невеличкий модуль, який можна уявити як «пам’ять» пристрою.
     Друга частина – це власне логіка роботи таймера. Тут реалізовано нескладний алгоритм: спочатку запускається сесія, потім – перерва, після чого цикл повторюється. Якщо сервер надсилає команду зупинки, цикл коректно завершується. Усе це відбувається без участі користувача – пристрій просто робить те, що йому наказали.
     Третя частина забезпечує зв’язок із сервером. IoT-клієнт регулярно звертається до бекенду та запитує, чи немає нової команди. Якщо сервер надсилає команду START – клієнт оновлює налаштування та запускає цикл. Якщо STOP – зупиняє роботу. Такий підхід нагадує модель «пристрій опитує сервер», яка досить типова для простих IoT-рішень.
     Щоб підтримати цей механізм, на сервері додано окремий маршрутизатор, який відповідає за передачу команд клієнту. Команди не зберігаються в базі даних – вони тимчасові, живуть лише кілька секунд і зникають після того, як клієнт їх прочитав.
     Одже, IoT-клієнт – це невелика, але самостійна частина системи. Він не потребує реального пристрою, але поводиться саме так, як поводився б ESP32 у розумному таймері: отримує команду, виконує її, переходить у перерву й чекає наступної. Його легко розширити або перенести на фізичний модуль, але для лабораторної роботи така імітація повністю покриває функціональні вимоги.
     2. UML діаграма  прецедентів для ІоТ клієнта
     У системі IoT-клієнт виконує доволі конкретну роль, тому діаграма прецедентів тут виходить компактною. Головна ідея полягає в тому, що клієнт не «живе сам по собі», а реагує на команди, які надсилає серверна частина. По суті, сервер для нього — це єдиний зовнішній актор, який може ініціювати якусь дію. Користувач опосередковано впливає на пристрій через інтерфейс або API, але безпосередньо з IoT-клієнтом він не взаємодіє.
     Тому діаграма показує дуже просту модель: сервер надсилає команду, IoT-клієнт її виконує. Завдання IoT-клієнта — коректно почати фокус-сесію, закінчити її, виконати перерву й завершити роботу, якщо сервер дає команду STOP.
     У вигляді діаграми це виглядає так:

     У текстовому описі можна подати це так:
     • сервер виступає єдиним актором;
     • IoT-клієнт реагує на дві основні команди — START та STOP;
     • після старту він сам керує своїми підпроцесами: робочою фазою і фазою відпочинку;
     • завершення роботи відбувається тільки тоді, коли сервер надсилає відповідну команду.
     3. Бізнес логіка та функції налаштування ІоТ клієнта
     Оскільки принцип роботи IoT-клієнта вже описано у першому розділі, тут зупинимось не на структурі, а саме на тому, що вважається його бізнес-логікою – тобто тією частиною, яка визначає поведінку пристрою, а не лише його будову.
     У нашому випадку бізнес-логіка базується на циклічній зміні двох режимів: фокусування і перерви. Клієнт переходить між цими фазами автоматично, поки не отримає зовнішню команду про зупинку. Тобто центральним елементом є не сам факт отримання команди (про це вже йшлося в розділі 1), а те, як пристрій поводиться після того, як команда надійшла.
     IoT-клієнт сприймає параметри тривалості «робочої» та «відпочинкової» фаз як власні налаштування. Він не зберігає їх у пам’яті й не оперує ними між сесіями – кожен запуск відбувається «з чистого листа», що цілком природно для пристрою, який отримує конфігурацію від серверної системи у момент запуску. Таким чином, налаштування тут – це не окреме меню, а просто частина команди, яку сервер надсилає в реальному часі.
     Сам цикл складається з двох простих відліків часу. Спершу клієнт очікує визначену кількість секунд (фаза фокусування), після чого переходить у перерву – і знову працює таймер. Цей механізм повторюється стільки разів, скільки потрібно, і лише команда STOP перериває процес. Завдяки такій поведінці пристрій працює автономно й не потребує подальших вказівок, доки конфігурація лишається незмінною.
     У реальних IoT-системах такі механізми часто реалізуються апаратно (через інтервали або таймери мікроконтролера). Тут ми повторили ту ж ідею у програмній формі, зберігаючи природну логіку роботи пристрою. Клієнт не «думає» про стан бази даних і не керує зовнішніми сутностями – його завдання лише виконати алгоритм, який задає сервер, що й виконується у нашій реалізації.
     4. Діаграма діяльності для ІоТ клієнта
     Ця діаграма показує природний цикл роботи IoT-клієнта з моменту запуску до завершення сесії. Вона відображає найважливіше: пристрій не починає жодних дій сам — він чекає команди, а після отримання діє автономно, поки не буде зупинений. Це дозволяє побачити, як взаємодіють внутрішні стани клієнта між собою.
     Нижче наведено діаграму діяльності у PlantUML.

     
     5. Програмна реалізація бізнес логіки та функцій налаштування ІоТ клієнта
     Програмна реалізація IoT-клієнта складається з трьох невеликих модулів, які разом утворюють логіку фокус-сесії. Ідея досить проста: пристрій отримує настройки від сервера, зберігає їх у своєму внутрішньому стані і далі працює автономно – доки не отримає команду зупинитись. У цьому розділі наведено ті частини коду, які безпосередньо відповідають за поведінку клієнта, і дають розуміння, як працює весь цикл.
     Файл iotState.js не містить складної логіки – лише зберігає актуальні параметри, які приходять від сервера. Це своєрідна "пам’ять" клієнта, де лежить тривалість сесії, перерви, прапорець зупинки та інформація про те, чи цикл уже запущений.
     // Глобальний стан IoT-пристрою (імітація ESP32)
     export let deviceState = {
         running: false,        // чи працює цикл
         stopRequested: false,  // чи потрібно зупинити цикл
         focusDuration: 0,      // тривалість фокус-сесії (мс)
         breakDuration: 0       // тривалість перерви (мс)
     };
     // Оновити стан пристрою
     export function updateState(data) {
         Object.assign(deviceState, data);
     }
     Цей модуль використовується всіма іншими частинами клієнта, тому що саме тут зберігається ключ – чи потрібно пристрою продовжувати цикл, чи варто його завершити.
     Основний алгоритм, який керує поведінкою IoT-клієнта, розташований у файлі iotLogic.js. Саме тут реалізовано цикл, що повторюється, і механізм зупинки, який спрацьовує після надходження відповідної команди.
     import { deviceState, updateState } from "./iotState.js";
     // Проста функція очікування
     function wait(ms) {
         return new Promise(resolve => setTimeout(resolve, ms));
     }
     // Основний цикл роботи пристрою (фокус → перерва → фокус ...)
     export async function runFocusCycle() {
         console.log("▶️ Фокус-сесія запущена");
         updateState({ running: true, stopRequested: false });
         while (!deviceState.stopRequested) {
             // Фокус-сесія
             console.log(`💡 Робоча сесія: ${deviceState.focusDuration / 1000} сек`);
             await wait(deviceState.focusDuration);
             if (deviceState.stopRequested) break;
             // Перерва
             console.log(`🔔 Перерва: ${deviceState.breakDuration / 1000} сек`);
             await wait(deviceState.breakDuration);
         }
         updateState({ running: false });
         console.log("⛔ Цикл зупинено");
     }
     Тут чітко видно, що логіка спирається на два часових параметри, які приходять із сервера. Клієнт відміряє потрібну кількість секунд, нічого не зберігає в базу і не здійснює жодних зовнішніх операцій – лише працює як таймер.
     Файл iotClient.js відповідає за зв’язок з сервером. Клієнт не «стоїть на зв’язку», а періодично опитує бекенд і питає, чи не надійшла нова команда. Якщо сервер надсилає START – пристрій налаштовує тривалості сесій і запускає цикл. Якщо STOP – піднімає прапорець, який зупиняє роботу.
     import axios from "axios";
     import { updateState, deviceState } from "./iotState.js";
     import { runFocusCycle } from "./iotLogic.js";
     const SERVER = "http://localhost:5000";
     async function pollCommands() {
         console.log("📡 IoT-клієнт запущено...");
         setInterval(async () => {
             try {
                 const res = await axios.get(SERVER + "/devices/command");
                 const cmd = res.data;
                 // START
                 if (cmd.type === "start" && !deviceState.running) {
                     updateState({
                         focusDuration: cmd.focus * 1000,
                         breakDuration: cmd.break * 1000
                     });
                     console.log("🚀 Команда START отримана");
                     runFocusCycle();
                 }
                 // STOP
                 if (cmd.type === "stop") {
                     console.log("🛑 Команда STOP отримана");
                     updateState({ stopRequested: true });
                 }
             } catch (err) {
                 console.log("❌ Помилка зв’язку з сервером:", err.message);
             }
         }, 2000);
     }
     pollCommands();
     Власне, тут і реалізовано «налаштування» пристрою: він не має окремого меню чи EEPROM, як апаратний ESP32 — замість цього кожен запуск сесії отримує свої параметри від сервера. Це повністю відповідає простим IoT-пристроям, які використовують HTTP-команди для роботи.
     Щоб IoT-клієнт міг отримувати налаштування, у серверну частину додано окремий маршрутизатор (deviceCommandRoutes.js). Він не зберігає команди у базі даних — вони тимчасові та живуть рівно стільки, скільки потрібно.
     import express from "express";
     const router = express.Router();
     // Тимчасове зберігання останньої команди (НЕ в БД)
     let lastCommand = { type: "none" };
     /*
         POST /devices/start
         {
             "focus": 1500,   // сек
             "break": 300     // сек
         }
     */
     router.post("/start", (req, res) => {
         const { focus, break: br } = req.body;
         lastCommand = {
             type: "start",
             focus,
             break: br
         };
         console.log("➡️  Команда START надіслана:", lastCommand);
         res.json({ message: "Команда START відправлена" });
     });
     /*
         POST /devices/stop
     */
     router.post("/stop", (req, res) => {
         lastCommand = { type: "stop" };
         console.log("🛑  Команда STOP надіслана");
         res.json({ message: "Команда STOP відправлена" });
     });
     /*
         GET /devices/command
         — IoT клієнт читає останню команду
     */
     router.get("/command", (req, res) => {
         res.json(lastCommand);
         // 👉 скидаємо команду, щоб не повторяти
         if (lastCommand.type === "start" || lastCommand.type === "stop") {
             lastCommand = { type: "none" };
         }
         // Якщо команда була START або STOP → після видачі
         // можна скинути її, щоб уникнути дублювання
         // але це НЕ обов'язково, тож залишаємо як є
     });
     export default router;
     Таким чином, сервер відіграє роль «пульта керування», а IoT-клієнт — слухняного виконавця, який працює строго за вказаним алгоритмом.
     6. Тестування роботи ІоТ клієнта

     Для знайдення та виклику пристрою ми виконали команду node src/iot/ioyClient.js –device=№; Після виклику йде перевірка, чи є в нас такий пристрій в базі чи ні. Якщо пристрій існує, він буде очікувати команди «start» та «stop».


     Після команди старт ми будемо отримувати такі повідомлення. Та побачимо, що наш цикл фокус-сесії був розпочат. Як ми бачимо з JsonBody наша фокус сесія має тривалість в 5 секунд, а брейк 3. Кожні 5 секунд у нас будуть повідомлення про перерву, та кожні 3, що час працювати.


     Після того як ми відправимо команду стоп, ми отримаємо повідомлення, що пристрій було зупиненно та цикл прерветься.

Додаток А
	Посилання на відео: https://youtu.be/9ocmLQ-2cqU


      
