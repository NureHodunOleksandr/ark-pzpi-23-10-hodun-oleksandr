Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
Кафедра програмної інженерії




Лабораторна робота №3
з дисципліни: «Аналіз та рефакторинг коду»
на тему: «РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ»





Виконав
ст. гр. ПЗПІ-23-10
Годун Олександр Васильович


Перевірили викладачі:
Дашенков Д. С.




Харків 2025
     
Мета роботи
	Розробити бізнес-логіку серверної частини програмної системи особистого планування, створити функції адміністрування, які забезпечують повний цикл управління даними користувачів, задач, категорій, статусів, підписок, аналітики, IoT-пристроїв і планувальників.
	Хід виконання роботи
1. Структура проєкту та налаштування середовища
	Для розробки серверної частини програмної системи «Personal Planner» було створено Node.js-проєкт із використанням фреймворку Express. Середовище налаштовано для підтримки REST-API, ORM Prisma та інтеграції з базою даних.
	Було встановлено такі основні пакети:
     * npm install express cors dotenv @prisma/client prisma open bcryptjs
     * npm install --save-dev nodemon
     	Конфігураційні параметри зберігаються у файлі .env, а запуск сервера виконується командами:
     * npm run dev     # режим розробки (з nodemon)
     * npm start       # звичайний запуск
     Структура серверного проєкту має вигляд:

     Для зручності тестування під час розробки використовується Thunder Client. Сервер автоматично відкривається у браузері після запуску, а повідомлення в консолі підтверджують коректну роботу:

2. Налаштування ORM Prisma та бази даних
     Для роботи з базою даних у серверній частині використано ORM Prisma, яка спрощує створення, оновлення та зв’язки між таблицями. У проєкті було створено директорію prisma/, де знаходяться основні файли конфігурації:
     * schema.prisma — опис структури бази даних;
     * seed.js — скрипт для початкового наповнення таблиць тестовими даними.
     У файлі schema.prisma визначено основні моделі:
     * users — зберігає інформацію про користувачів;
     * tasks — описує задачі з параметрами часу, статусом і категорією;
     * categories — групує задачі за напрямами діяльності;
     * statuses — фіксує поточний стан задачі (не виконано, виконано тощо);
     * statistics — зберігає аналітичні показники ефективності;
     * devices — описує підключені IoT-пристрої (ESP32);
     * planner та plannerSubscription — реалізують спільні планувальники та підписки користувачів.
     Для підключення до бази створено модуль prismaClient.js (Додаток А)
     Цей клієнт використовується у всіх контролерах системи для виконання CRUD-операцій. Перед першим запуском бази даних виконуються команди:
     * npx prisma generate      # створює клієнт ORM
     * npx prisma migrate dev   # застосовує структуру БД
     * npx prisma db seed       # заповнює тестовими даними
     	Після цього база містить попередньо створених користувачів, категорії, статуси, задачі, планувальник і пристрій ESP32, які використовуються для тестування бізнес-логіки.
3. Розробка основного серверного додатку
     Після налаштування середовища та бази даних було розпочато створення основного серверного застосунку. Серверна частина системи побудована за модульним принципом: окремо зберігаються маршрути, контролери з бізнес-логікою, клієнт бази даних Prisma та допоміжні файли.
     Основний файл застосунку — app.js. У ньому створюється екземпляр Express-сервера, підключаються бібліотеки cors та dotenv, а також реєструються всі маршрути системи. Завдяки цьому програма має чітку структуру, де кожен модуль відповідає лише за свою частину логіки.
     	Код app.js виглядає так: (Додаток Б)
     Цей файл виконує роль “центрального вузла”, який збирає всі частини системи разом. Кожен з підключених маршрутів (userRoutes, taskRoutes тощо) посилається на свій контролер, де вже описана конкретна бізнес-логіка (створення, оновлення, видалення тощо). Такий підхід дозволяє підтримувати проєкт у зручній формі — можна легко додавати нові модулі без зміни основного коду сервера.
     Запуск сервера реалізовано в окремому файлі server.js: (Додаток В)
     У результаті реалізації цього етапу вдалося побудувати повноцінний REST-сервер, який є центральною частиною всієї системи. Він приймає запити, викликає відповідні контролери, взаємодіє з базою даних і повертає структуровані JSON-відповіді. Таким чином, серверна частина готова до інтеграції з клієнтським інтерфейсом і забезпечує стабільну роботу всієї системи.
4. Реалізація маршрутизації REST-API
     Після створення основного застосунку було реалізовано систему маршрутизації, яка забезпечує обробку HTTP-запитів між клієнтською частиною та сервером. Для кожної сутності системи (користувачі, задачі, категорії, статуси, статистика, пристрої, планувальники) створено окремий файл маршруту у папці routes/.
     Кожен файл відповідає за свій набір REST-ендпоінтів, що реалізують CRUD-операції:
     * GET — отримання даних;
     * POST — створення нового запису;
     * PUT — оновлення;
     * DELETE — видалення.
     Наприклад, модуль taskRoutes.js має такий вигляд: (Додаток Г)
     Маршрути залишаються максимально лаконічними — вони лише приймають запит і передають його до відповідного контролера. Це дозволяє розділити логіку: контролери відповідають за обробку даних, а маршрути — лише за організацію звернень.
     Для більш складних сутностей, таких як планувальники (planner), маршрути містять додаткові шляхи, що підтримують спільну роботу кількох користувачів:
     router.post("/subscribe", subscribeToPlanner);
     router.delete("/unsubscribe", unsubscribeFromPlanner);
     router.get("/:id/subscribers", getPlannerSubscribers);
     router.put("/role", updateSubscriberRole);
     router.get("/user/:user_id", getUserSubscriptions);
     Така структура дозволяє не лише виконувати базові дії, а й обробляти розширені сценарії — підписки, ролі, автоматичне дублювання задач тощо. Для зручності тестування всі маршрути мають зрозумілу систему префіксів:
     /users – керування користувачами  
     /tasks – операції із задачами  
     /categories – робота з категоріями  
     /statuses – статуси задач  
     /statistics – аналітика продуктивності  
     /devices – IoT-пристрої (ESP32)  
     /planners – планувальники та підписки
     Маршрути підключаються до основного застосунку в app.js через app.use().
Це забезпечує централізовану схему обробки запитів і спрощує масштабування: у разі появи нових модулів достатньо додати ще один маршрутний файл без зміни структури сервера.
5. Розробка бізнес-логіки контролерів
     Після налаштування маршрутизації було створено набір контролерів, які реалізують бізнес-логіку серверної частини. Кожен контролер відповідає за окрему сутність системи — користувачів, задачі, категорії, статуси, аналітику, IoT-пристрої та планувальники. Контролери зберігаються в папці controllers/ і містять реалізацію основних CRUD-операцій.
     Контролер користувачів (userController.js)
     Відповідає за створення, оновлення, отримання та видалення користувачів.
Під час створення нового користувача пароль обов’язково хешується через бібліотеку bcrypt, щоб підвищити безпеку:
     const password_hash = await bcrypt.hash(password, 10);
     const user = await prisma.users.create({
       data: { email, password_hash, name, last_name, birth_date },
     });
     Також реалізовано можливість оновлення імені, прізвища та дати народження користувача. Усі дані зберігаються у таблиці users бази даних.
     Контролер задач (taskController.js)
     Найбільш складний і функціонально насичений модуль.
Крім стандартних CRUD-операцій, він реалізує кілька автоматичних процесів:
     * дублювання спільних задач усім підписникам планувальника;
     * створення нових категорій для підписників, якщо таких ще немає;
     * підтримка повторюваних задач через поле is_repeating.
     Фрагмент створення спільної задачі:
     if (is_shared && planner_id) {
       const subs = await prisma.plannerSubscription.findMany({ where: { planner_id: +planner_id } });
       for (const sub of subs) {
         if (sub.user_id === +user_id) continue;
         await prisma.tasks.create({
           data: {
             user_id: sub.user_id,
             planner_id: +planner_id,
             title, description,
             is_shared: false,
           },
         });
       }
     }
     Це дозволяє автоматично розповсюджувати спільні задачі серед усіх підписників певного планера. Крім того, якщо у користувача немає відповідної категорії, вона створюється автоматично з такими ж параметрами name і color.
     Контролер категорій (categoryController.js)
     Забезпечує створення, редагування та видалення категорій користувачів.
Категорії використовуються для розподілу задач за напрямами діяльності (робота, навчання, відпочинок тощо). Кожна категорія прив’язана до користувача через user_id.
     Контролер статусів (statusController.js)
     Контролер статистики (statisticsController.js) відповідає за автоматичний розрахунок показників продуктивності користувача. На відміну від базового CRUD-прикладу, у нашій реалізації статистика не створюється вручну.
У системі працює окрема функція calculateForUser(), яка аналізує всі задачі користувача і формує зведення продуктивності.
     При зверненні до ендпоінта:
     GET /statistics/user/:id
     контролер:
     1. отримує всі задачі користувача;
     2. визначає задачі зі статусами та підраховує:
     * відсоток виконаних задач,
     * кількість днів перевантаження,
     * баланс між категоріями,
     * співвідношення "робота / відпочинок",
     * динаміку прогресу (порівняння з попередньою статистикою);
     3. генерує текст рекомендації, враховуючи:
     * рівень продуктивності,
     * перевантаження,
     * перекіс у категоріях,
     * відсутність відпочинку або навпаки його надлишок;
     4. визначає найбільш завантажену та найменш завантажену категорії;
     5. якщо в користувача вже існує запис статистики — контролер оновлює його,
якщо ні — створює перший запис.
     Приклад збереженого запису (справжній формат, який генерує система):
     await prisma.statistics.update({
       where: { stats_id: existing.stats_id },
       data: {
         user_id,
         period: "current",
         completed_percent: 72,
         overload_days: 1,
         category_balance: 0.84,
         recommendation_text: "Все виглядає збалансовано: задачі виконуються, перевантаження немає."
       }
     });
     Замість статичних значень, як у простому прикладі,
система зберігає розраховані реальні показники для кожного користувача.
     Надалі ці дані можуть використовуватися клієнтською частиною
для побудови графіків продуктивності, динаміки ефективності та персональних порад.
     Алгоритм аналізу
     Алгоритм аналізу статистики у системі реалізований у функції calculateForUser(), яка викликається контролером під час отримання статистики користувача. На відміну від типових CRUD-операцій, цей модуль не зберігає наперед задані значення, а самостійно аналізує фактичний стан задач, обчислює ключові показники та формує рекомендації.
     Першим кроком система отримує всі задачі користувача. Якщо задач немає, аналіз зупиняється — немає даних для обчислень. Далі визначається статус, який вважається “виконаним”. Це потрібно для того, щоб обчислити основний показник продуктивності — відсоток завершених задач. Для цього враховуються тільки задачі, у яких взагалі встановлено статус. Такі задачі утворюють окремий набір, оскільки задачі без статусу не можуть впливати на результат. На основі цих даних система визначає, скільки задач виконано, а скільки — ні, і рахує відсоток виконання.
     Паралельно алгоритм оцінює рівень навантаження користувача. За умовною моделлю, приблизно п’ять задач зі статусом відповідають одному “перевантаженому дню”. Це не формальна математична метрика, але вона дозволяє виявити ситуації, коли користувач бере на себе занадто багато справ.
     Потім задачі групуються за категоріями. На основі їх кількості система обчислює баланс між категоріями: чим сильніше кількість задач у категоріях відрізняється одна від одної, тим нижчий баланс. Якщо категорій багато, але задач у них однаково — баланс вважається високим. У випадку рівного розподілу система не виділяє “найбільш” або “найменш” завантажену категорію, щоб не робити хибних висновків.
     Далі алгоритм визначає, до якого типу належать задачі — робочого чи відпочинкового. Це робиться за ключовими словами в назвах категорій. Такий підхід дає можливість формувати рекомендації про співвідношення роботи та відпочинку, що важливо для оцінки загального балансу навантаження.
     Ще один елемент — порівняння поточного результату з попереднім записом статистики. Якщо у користувача вже була збережена статистика, система порівнює новий відсоток виконання з попереднім і визначає динаміку продуктивності: покращилася вона чи погіршилася. Якщо це перший аналіз, зміна не фіксується.
     На основі усіх цих даних формується рекомендація. Її текст залежить від поєднання кількох факторів: рівня продуктивності, наявності або відсутності перевантаження, ступеня збалансованості категорій, а також співвідношення задач, пов’язаних з роботою чи відпочинком. Наприклад, при високій продуктивності та збалансованих категоріях система дає позитивну оцінку. Якщо ж продуктивність невисока, або користувач бере на себе занадто багато задач, або, навпаки, має значний перекіс у категоріях, алгоритм формує відповідну пораду. У випадках, коли помітний дисбаланс між роботою та відпочинком, рекомендація доповнюється підказками щодо покращення цього співвідношення.
     Після завершення аналізу контролер або оновлює наявний запис статистики користувача, або створює перший, якщо його ще не було. Таким чином кожен запит до статистики забезпечує користувача актуальними даними та поясненнями, що ґрунтуються на реальному стані його задач.
     Контролер пристроїв (deviceController.js)
     Реалізує логіку роботи з IoT-модулями ESP32, які використовуються як фізичні таймери фокус-сесій. Пристрій реєструється у системі за допомогою esp_id, а його стан можна змінювати (наприклад, active / inactive):
     const device = await prisma.devices.update({
       where: { device_id: +id },
       data: { state },
     });
     Таким чином, сервер синхронізується з реальним пристроєм, який сигналізує користувачу про початок або завершення фокус-сесії.
     Контролер планувальників (plannerController.js)
     Цей модуль об’єднує користувачів у спільні робочі групи (planner).
Реалізовано функції:
     * створення нового планувальника з автоматичним додаванням власника (роль OWNER);
     * підписка інших користувачів (subscribeToPlanner);
     * відписка з автоматичним видаленням копій задач (unsubscribeFromPlanner);
     * зміна ролей користувачів (updateSubscriberRole).
     Фрагмент логіки відписки:
     await prisma.tasks.deleteMany({
       where: {
         planner_id: +planner_id,
         user_id: +user_id,
         is_shared: false, // щоб не видаляти задачі власника
       },
     });
     6. Реалізація автоматичних процесів у бізнес-логіці
     Окрім стандартних CRUD-операцій, у системі Personal Planner реалізовано низку автоматичних процесів, які забезпечують розумну взаємодію між користувачами, задачами, категоріями, статистикою та IoT-пристроями.
Ці процеси створюють основу бізнес-логіки — вони працюють без втручання користувача та підтримують цілісність даних у спільних планувальниках.
     * Автоматичне дублювання спільних задач
     Коли користувач створює задачу з ознакою is_shared = true, система автоматично дублює її для всіх підписників відповідного планувальника.
Це дозволяє членам однієї команди бачити однакові завдання у своїх списках.
     Фрагмент із taskController.js:
     if (is_shared && planner_id) {
       const subs = await prisma.plannerSubscription.findMany({
         where: { planner_id: +planner_id },
         include: { user: true },
       });
       for (const sub of subs) {
         if (sub.user_id === +user_id) continue; // не дублюємо власнику
         await prisma.tasks.create({
           data: {
             user_id: sub.user_id,
             planner_id: +planner_id,
             title, description,
             category_id: newCategoryId,
             is_shared: false,
           },
         });
       }
     }
     * Автоматичне створення категорій у підписників
     Якщо спільна задача належить до певної категорії (наприклад, “Робота”), а у підписника ще немає такої, система автоматично створює її з тим самим ім’ям і кольором.
     Фрагмент із того ж контролера:
     if (category_id) {
       const origCat = await prisma.categories.findUnique({
         where: { category_id: +category_id },
       });
       let existing = await prisma.categories.findFirst({
         where: { user_id: sub.user_id, name: origCat.name },
       });
       if (!existing) {
         existing = await prisma.categories.create({
           data: {
             user_id: sub.user_id,
             name: origCat.name,
             color: origCat.color,
           },
         });
       }
       newCategoryId = existing.category_id;
     }
     Це забезпечує узгодженість структури даних між усіма учасниками планувальника.
     * Видалення копій задач при відписці від планувальника
     Коли користувач вирішує відписатися від спільного планувальника, система не лише видаляє його підписку, а й очищає усі дубльовані задачі, створені раніше. Це виконується у функції unsubscribeFromPlanner() контролера plannerController.js:
     await prisma.tasks.deleteMany({
       where: {
         planner_id: +planner_id,
         user_id: +user_id,
         is_shared: false, // щоб не видалити задачі власника
       },
     });
     Такий підхід допомагає уникнути накопичення зайвих записів у базі та зберігає порядок у системі.
     * Оновлення ролей користувачів
     У спільному планувальнику кожен підписник має свою роль: OWNER, ADMIN або USER. Адміністратор може змінювати ролі інших користувачів, і це відображається в таблиці plannerSubscription.
     Фрагмент із plannerController.js:
     const updated = await prisma.plannerSubscription.updateMany({
       where: { planner_id: +planner_id, user_id: +user_id },
       data: { role },
     });
     Цей механізм дозволяє реалізувати гнучку систему доступів у межах одного планувальника.
     * Формування аналітики продуктивності
     Бізнес-логіка системи включає простий, але зрозумілий модуль аналітики.
Він не використовує штучний інтелект — усі показники розраховуються логічно на основі виконаних задач і зберігаються у таблиці statistics. Приклад створення запису:
     await prisma.statistics.create({
       data: {
         user_id,
         period: "2025-Q1",
         completed_percent: 85.5,
         overload_days: 2,
         category_balance: 0.9,
         recommendation_text: "Зберігайте баланс між роботою та відпочинком ",
       },
     });
     Показники використовуються для побудови графіків і текстових рекомендацій у клієнтському інтерфейсі.
     * Синхронізація з IoT-пристроями
     До системи можна підключити IoT-пристрій на базі ESP32, який сигналізує про початок і завершення фокус-сесій. Коли користувач починає або завершує роботу, клієнт надсилає запит до ендпоінта /devices/:id, який оновлює стан пристрою в базі:
     const device = await prisma.devices.update({
       where: { device_id: +id },
       data: { state },
     });
     Це забезпечує синхронізацію між цифровим планувальником і фізичним пристроєм у режимі реального часу. Усі ці автоматичні механізми роблять систему Personal Planner динамічною та зручною для спільної роботи. Користувачеві не потрібно вручну дублювати задачі, створювати категорії чи оновлювати ролі — система робить це самостійно, що суттєво спрощує взаємодію та підтримує цілісність даних у базі.
     7. Розробка функцій адміністрування
     В систему було додано функції адміністрування, які дозволяють керувати даними напряму через REST-запити. Окрему панель адміністратора поки не створювали — усі перевірки виконувалися через Thunder Client, що дало змогу швидко тестувати роботу серверної частини.
     Адміністрування охоплює всі основні сутності системи — користувачів, задачі, категорії, статуси, статистику, пристрої та спільні планувальники.
Адміністратор має доступ до повного набору CRUD-операцій, тобто може переглядати, редагувати або видаляти будь-які записи в базі.
     Для прикладу, видалення запису зі статистики користувача реалізовано через контролер statisticsController.js:
     export async function deleteStatistics(req, res) {
       const { id } = req.params;
       await prisma.statistics.delete({
         where: { stats_id: parseInt(id) },
       });
       res.json({ message: "Запис статистики видалено" });
     }
     Запит виконується через метод DELETE /statistics/:id, після чого у відповіді повертається повідомлення про успішне видалення. Аналогічний принцип застосовано для інших сутностей: користувачів, задач, категорій, статусів, пристроїв та планувальників.
     У межах адміністрування також реалізовано зміну ролей користувачів у спільних планувальниках. Це дає змогу призначати нових адміністраторів або передавати права власності. Такі дії забезпечують гнучкість у керуванні даними й дозволяють швидко реагувати на зміни у структурі користувачів.
     8. Перевірка роботи REST-інтерфейсу
     Після реалізації всіх маршрутів і контролерів було проведено перевірку роботи REST-інтерфейсу за допомогою розширення Thunder Client у Visual Studio Code. Метою тестування було впевнитися, що всі основні запити (GET, POST, PUT, DELETE) працюють коректно й сервер правильно обробляє передані дані. Для кожної сутності виконувались тестові запити з реальними параметрами.

Рисунок 1 – ендепоінд Get у Tasks


Рисунок 2 – ендепоінд Post у Tasks


Рисунок 3 – ендепоінд UpDate у Tasks

Рисунок 4 – ендепоінд Delete у Tasks
     Результати підтвердили, що всі CRUD-операції виконуються коректно, а сервер стабільно обробляє запити клієнтів. Ті ж самі результати були отримані при тестуванні інших сутностей.
     Під час тестів сервер стабільно відповідав із кодами 200, 201 або 204, що свідчить про правильну обробку запитів. Помилки при передачі некоректних параметрів оброблялись через блоки try/catch, і система повертала коректне повідомлення з кодом 500 або 400.
     9. Висновок
     У ході виконання лабораторної роботи було розроблено та протестовано серверну частину системи «Personal Planner», яка забезпечує повний набір функцій для роботи з користувачами, задачами, категоріями, статусами, аналітикою, планувальниками та IoT-пристроями.
     Побудовано чітку структуру проєкту, налаштовано ORM Prisma та базу даних, реалізовано REST-інтерфейс із розділенням маршрутів і бізнес-логіки.
У процесі роботи було впроваджено автоматичні механізми — дублювання спільних задач, створення категорій для підписників, видалення задач при відписці, оновлення ролей і синхронізацію з ESP32-модулем.
     Після тестування через Thunder Client підтверджено, що всі ендпоінти працюють стабільно, сервер повертає коректні JSON-відповіді, а база даних оновлюється згідно з виконаними запитами. Система готова до інтеграції з клієнтською частиною й подальшого розширення функцій адміністрування через веб-інтерфейс.
ДОДАТОК ПОСИЛАННЯ НА ВІДЕО
	https://youtu.be/TMSGmhKWmTw
ДОДАТОК А
     Код файлу prismaClient.js:
       import { PrismaClient } from "@prisma/client";
       
       const prisma = new PrismaClient();
       
       process.on("SIGINT", async () => {
         await prisma.$disconnect();
         console.log("Prisma Client: з'єднання з базою даних закрито.");
         process.exit(0);
       });
       
       export default prisma;
       

ДОДАТОК Б
     Код файлу app.js:
       import express from "express";
       import cors from "cors";
       import dotenv from "dotenv";
       import userRoutes from "./routes/userRoutes.js";
       import taskRoutes from "./routes/taskRoutes.js";
       import categoryRoutes from "./routes/categoryRoutes.js";
       import statusRoutes from "./routes/statusRoutes.js";
       import deviceRoutes from "./routes/deviceRoutes.js";
       import statisticsRoutes from "./routes/statisticsRoutes.js";
       import plannerRoutes from "./routes/plannerRoutes.js";
       dotenv.config();
       const app = express();
       
       app.use(cors());
       app.use(express.json());
       // Маршрути
       app.use("/users", userRoutes);
       app.use("/tasks", taskRoutes);
       app.use("/categories", categoryRoutes);
       app.use("/statuses", statusRoutes);
       app.use("/devices", deviceRoutes);
       app.use("/statistics", statisticsRoutes);
       app.use("/planners", plannerRoutes);
       // Головна перевірка API
       app.get("/", (req, res) => {
         res.send("Planner API працює ✅");
       });
       export default app;

ДОДАТОК В
     Код файлу server.js:
       import open from "open"; // <-- додай імпорт угорі (новий пакет)
       import app from "./app.js";
       
       const PORT = process.env.PORT || 5000;
       
       app.listen(PORT, () => {
         console.log(`✅ Server running on port ${PORT}`);
         open(`http://localhost:${PORT}`); // <-- автоматично відкриває браузер
       });
       

ДОДАТОК Г
       import express from "express";
       import {
         createTask,
         getTasks,
         updateTask,
         deleteTask,
       } from "../controllers/taskController.js";
       
       const router = express.Router();
       
       router.post("/", createTask);
       router.get("/", getTasks);
       router.put("/:id", updateTask);
       router.delete("/:id", deleteTask);
       
       export default router;




      
